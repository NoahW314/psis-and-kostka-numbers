-- Thanks to Alexandra Seceleanu for providing most of this code

-- returns the symmetric ideal generated by the list of polynomials L
genSymIdeal = L -> (
    R := ring L_0;
    d := dim R;
    u := gens R;
    l := apply(permutations(d), p->map(R, R, for i to d-1 list u_i=> R_(p_i)));
    return trim sum apply(L, f-> ideal apply(l, sigma-> sigma(f)))
)


-- checks if an ideal is symmetric
isSymIdeal = I -> (
    R := ring I;
    d := dim R;
    u := gens R;
    gensI := for i to (numgens I)-1 list (mingens I)_(0,i);
    l := apply(permutations(d), p->map(R, R, for i to d-1 list u_i=> R_(p_i)));
    for i to #l-1 do (
        for g in gensI do (
            if ( ((l_i)(g) % I ) != 0 ) then return false;
     	);
    );
    return true;
)

needsPackage "BettiCharacters";
needsPackage "SpechtModule";
-- The last line returns the partitions corresponding to the Specht module
-- decomposition of the span of the generators for the input ideal I in the
-- format {partition} => multiplicity of that partition.
spechtModuleMult = I -> (
    R := ring I;
    n := dim ring I;
    r := complex presentation (ring I / I );
    -- make symmetric group
    G := for p in partitions(n) list (
        L := gens R;
        g := for u in p list (
            l := take(L,u);
            L = drop(L,u);
            rotate(1,l)
        );
        matrix { flatten g }
    );
    A:=action(r,G);
    c:=character (A,1);
    irrReps := new HashTable from pack(2,
        mingle {
            partitions n,
                apply(entries (characterTable n)#values, r -> mutableMatrix{r})
           }
    );
    multiplicities := c -> select(
          applyValues(irrReps,
              v -> innerProduct(n,v,mutableMatrix{values c.characters})),
          v -> v!=0
    );
    multiplicities c
)

-- finds the minimum r such that a symmetric ideal I is r-generated
-- this makes use of the corollary in the paper that characterizes r-generated symmetric ideals
numMinSymGens = I -> (
    mults := spechtModuleMult I;
    ceiling(lift(max(apply(pairs(mults), (p, n) -> n / hookLengthFormula(p) )), QQ))
)

-- determines if a symmetric ideal I is a principal symmetric ideal
isPSI = I -> (
    (numMinSymGens I) == 1
)
